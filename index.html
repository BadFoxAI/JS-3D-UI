
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS-3D-UI - Tech Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #info {
            position: absolute; top: 10px; left: 10px; padding: 8px;
            background-color: rgba(0, 0, 0, 0.7); color: white;
            font-family: Arial, sans-serif; font-size: 14px;
            border-radius: 4px; z-index: 1000;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">JS-3D-UI - Tech Demo</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- Global Configuration ---
        const RESOLUTION_FACTOR = 100;
        const GLOBAL_DEFAULT_STYLE = {
            fontFamily: 'Arial', fontSize: 36, textColor: '#FFFFFF',
            backgroundColor: '#007bff', hoverBackgroundColor: '#0056b3',
            focusBackgroundColor: '#003c7a', activeBackgroundColor: '#002752',
            textInputFocusColor: '#004494', placeholderTextColor: '#BBBBBB',
            width: 2.5, height: 0.5, itemSpacing: 0.1,
            textAlign: 'center', verticalAlign: 'middle',
            padding: 0.05,
        };
        const BLINK_INTERVAL = 530;

        // --- THEMES constant (even if not fully used by Menu constructor yet) ---
        const THEMES = {
            default: { /* ... can be same as GLOBAL_DEFAULT_STYLE or slightly different ... */
                fontFamily: 'Arial', fontSize: 36, textColor: '#FFFFFF',
                backgroundColor: '#007bff', hoverBackgroundColor: '#0056b3',
                focusBackgroundColor: '#003c7a', activeBackgroundColor: '#002752',
                textInputFocusColor: '#004494', placeholderTextColor: '#BBBBBB',
            },
            darkDebug: { fontFamily: 'Courier New, monospace', fontSize: 30, fontColor: '#00FF00', backgroundColor: '#101010', hoverColor: '#303000', activeColor: '#505000', textInputFocusColor: '#005500', placeholderTextColor: '#008800',}
        };


        // --- Menu Definition (Global Scope) ---
        const testMenuDefinition = {
            id: 'mainTestMenu',
            type: 'panel',
            position: new THREE.Vector3(0, 1.5, 0),
            style: { itemSpacing: 0.15, width: 3.2 }, // Style for the menu itself
            items: [
                { name: "title", type: 'textlabel', text: "UI Test Menu (Iter 0.7)", style: { height: 0.3, fontSize: 40, backgroundColor: '#333', hoverBackgroundColor:'#333' } },
                { name: "nameField", type: 'text_input', value: "Test User", placeholder: "Enter Name", style: {width:3, height:0.5, fontSize:40}},
                { name: "btnConfirm", type: 'button', text: "Log Name",
                  actionKey: "logNameAction",
                  style: { width: 2, height: 0.4}
                }
            ]
        };


        // --- Global State ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let interactiveElements = []; // Note: UIElement3D.dispose manages this for its own mesh. Menu system might need its own tracking for raycasting targets.
        let hoveredElement = null; // Managed by interaction handlers
        // let focusedElement = null; // Now primarily managed by menuManager.focusedItem
        let activeElement = null; // Managed by interaction handlers
        let blinkTimer = null;
        let cursorVisible = true;
        let menuManager;
        // let mouseInteractionHandler, xrInteractionHandler; // Initialized in init()


        // --- UIElement3D Base Class ---
        class UIElement3D {
            constructor(config = {}) { this.id = config.name || `uiElement_${THREE.MathUtils.generateUUID()}`; this.mesh = null; this.style = { ...GLOBAL_DEFAULT_STYLE, ...config.styleFromMenu, ...config.style }; if (typeof this.style.padding === 'number') { this.style.padding = { top: this.style.padding, right: this.style.padding, bottom: this.style.padding, left: this.style.padding }; } else { const pVal = (typeof GLOBAL_DEFAULT_STYLE.padding === 'number') ? GLOBAL_DEFAULT_STYLE.padding : 0.05; this.style.padding = { top: this.style.padding?.top ?? pVal, right: this.style.padding?.right ?? pVal, bottom: this.style.padding?.bottom ?? pVal, left: this.style.padding?.left ?? pVal };} this.userData = { config: config, isHovered: false, isFocused: false, isActive: false, uiElementInstance: this }; this.type = config.type || 'uibase'; this.visible = true; this.renderer = config.renderer; this.menuManager = config.menuManager; }
            createMesh() { throw new Error(`UIElement3D (${this.id}): createMesh() must be implemented by subclass.`); }
            updateAppearance(newBgColor, newTextColor = null, newText = null, showCursor = false) { if (this.mesh && this.mesh.userData.updateTextureMethod) { this.mesh.userData.updateTextureMethod(newBgColor, newTextColor, newText, showCursor); } else if (this.mesh && this.mesh.material && this.mesh.material.color && newBgColor) { this.mesh.material.color.set(newBgColor);}}
            onHover() { if (!this.visible || this.userData.isFocused || this.userData.isActive) return; this.userData.isHovered = true; this.updateAppearance(this.style.hoverBackgroundColor); }
            onUnhover() { if(!this.visible) return; this.userData.isHovered = false; if (this.userData.isFocused) { this.updateAppearance(this.style.focusBackgroundColor, null, null, this.type === 'text_input' ? cursorVisible : false); } else if (this.userData.isActive) { this.updateAppearance(this.style.activeBackgroundColor); } else { this.updateAppearance(this.style.backgroundColor); } }
            onClick() { this.setFocus(true); }
            onMouseDown() {} onMouseUp() {}
            onKeyDown(event) { console.log(`Key '${event.key}' (UIElement3D default handler) on focused ${this.id}`);}
            setFocus(focused) { if (!this.menuManager) { console.warn("UIElement3D: menuManager is not set for focus management on element " + this.id); return; } if (this.userData.isFocused === focused) return; this.userData.isFocused = focused; this.userData.isHovered = false; if (this.userData.isFocused) { if (this.menuManager.focusedItem && this.menuManager.focusedItem !== this) { this.menuManager.focusedItem.setFocus(false); } this.menuManager.focusedItem = this; this.updateAppearance(this.style.focusBackgroundColor, null, null, this.type === 'text_input' ? cursorVisible : false); console.log(`Focused: ${this.id}`); if (this.type === 'text_input') startBlinkingCursor(); } else { if (this.menuManager.focusedItem === this) { this.menuManager.focusedItem = null; } if (this.type === 'text_input') stopBlinkingCursor(); this.updateAppearance(this.style.backgroundColor); console.log(`Unfocused: ${this.id}`); } }
            dispose() { if (this.mesh) { if (this.mesh.geometry) this.mesh.geometry.dispose(); if (this.mesh.material) { if (this.mesh.material.map && this.mesh.material.map.dispose) this.mesh.material.map.dispose(); if(this.mesh.material.dispose) this.mesh.material.dispose(); } if (this.mesh.parent) this.mesh.parent.remove(this.mesh); this.mesh = null;} const index = interactiveElements.indexOf(this.mesh); if (index > -1) interactiveElements.splice(index, 1); if (hoveredElement === this) hoveredElement = null; if (this.menuManager && this.menuManager.focusedItem === this) {this.menuManager.focusedItem = null; if (this.type === 'text_input') stopBlinkingCursor();} if (activeElement === this) activeElement = null; } // interactiveElements.indexOf(this.mesh) might be intended
        }

        class TextLabelElement extends UIElement3D { constructor(config) { super(config); this.text = config.text || "Label"; this.type = 'textlabel'; this.mesh = this.createMesh(); if (this.mesh && config.position) this.mesh.position.copy(config.position); if (this.mesh && config.rotation) this.mesh.rotation.copy(config.rotation); if (this.mesh) interactiveElements.push(this.mesh); } createMesh() { const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const currentStyle = this.style; const canvasWidth = Math.floor(currentStyle.width * RESOLUTION_FACTOR); const canvasHeight = Math.floor(currentStyle.height * RESOLUTION_FACTOR); canvas.width = canvasWidth; canvas.height = canvasHeight; const texture = new THREE.CanvasTexture(canvas); const updateTextureMethod = (newBgColor, newTextColor = null, newText = null, showCursor = false) => { context.fillStyle = newBgColor || currentStyle.backgroundColor; context.fillRect(0, 0, canvasWidth, canvasHeight); const textToRender = newText || this.text; context.font = `Bold ${currentStyle.fontSize}px ${currentStyle.fontFamily}`; context.fillStyle = newTextColor || currentStyle.textColor; const paddingPx = { top: currentStyle.padding.top * RESOLUTION_FACTOR, right: currentStyle.padding.right * RESOLUTION_FACTOR, bottom: currentStyle.padding.bottom * RESOLUTION_FACTOR, left: currentStyle.padding.left * RESOLUTION_FACTOR }; const textHeightApproximation = currentStyle.fontSize; let x, y; context.textAlign = currentStyle.textAlign; if (currentStyle.textAlign === 'left') { x = paddingPx.left; } else if (currentStyle.textAlign === 'right') { x = canvasWidth - paddingPx.right; } else { x = canvasWidth / 2; } context.textBaseline = currentStyle.verticalAlign; if (currentStyle.verticalAlign === 'top') { y = paddingPx.top; } else if (currentStyle.verticalAlign === 'bottom') { y = canvasHeight - paddingPx.bottom; } else { y = canvasHeight / 2; } if(context.textBaseline === 'top') y += textHeightApproximation * 0.75; else if (context.textBaseline === 'bottom') y -= textHeightApproximation * 0.25; context.fillText(textToRender, x, y); texture.needsUpdate = true; }; updateTextureMethod(currentStyle.backgroundColor, currentStyle.textColor, this.text, false); const geometry = new THREE.PlaneGeometry(currentStyle.width, currentStyle.height); const material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7, metalness: 0.1, transparent: true, side: THREE.DoubleSide }); const mesh = new THREE.Mesh(geometry, material); mesh.name = this.id; mesh.userData = this.userData; mesh.userData.updateTextureMethod = updateTextureMethod; mesh.userData.uiElementInstance = this; return mesh; } setText(newText) { this.text = newText; let bgColor = this.style.backgroundColor; if (this.userData.isFocused) bgColor = this.style.focusBackgroundColor; else if (this.userData.isHovered) bgColor = this.style.hoverBackgroundColor; this.updateAppearance(bgColor, null, this.text, false); } updateAppearance(newBgColor, newTextColor = null, newText = null, showCursor = false) { if (this.mesh && this.mesh.userData.updateTextureMethod) { this.mesh.userData.updateTextureMethod(newBgColor, newTextColor, newText === null ? this.text : newText, showCursor); } } }
        class ButtonElement extends TextLabelElement { constructor(config) { super(config); this.type = 'button'; this.action = config.actionKey ? null : (config.action || (() => {console.log(`Button '${this.id}' clicked, no direct action defined.`); if(this.actionKey && this.menuManager) this.menuManager.executeAction(this.actionKey, this);})); if(config.actionKey && this.menuManager) this.actionKey = config.actionKey; else this.actionKey = null; } onClick() { super.onClick(); if (this.action) { this.action(); } else if (this.actionKey && this.menuManager) { this.menuManager.executeAction(this.actionKey, this); } } onMouseDown() { if (this.userData.isFocused && this.type === 'button') return; this.userData.isActive = true; this.updateAppearance(this.style.activeBackgroundColor); } onMouseUp() { this.userData.isActive = false; if (this.userData.isFocused) { this.updateAppearance(this.style.focusBackgroundColor); } else if (this.userData.isHovered) { this.updateAppearance(this.style.hoverBackgroundColor); } else { this.updateAppearance(this.style.backgroundColor); } } }
        class TextInputElement extends UIElement3D { constructor(config) { const textInputDefaultStyle = { backgroundColor: '#FFFFFF', textColor: '#000000', placeholderTextColor: GLOBAL_DEFAULT_STYLE.placeholderTextColor, textAlign: 'left', verticalAlign: 'middle', padding: { top: 0.05, right: 0.1, bottom: 0.05, left: 0.1 }, focusBackgroundColor: GLOBAL_DEFAULT_STYLE.textInputFocusColor, hoverBackgroundColor: '#F0F0F0', }; const finalStyle = { ...GLOBAL_DEFAULT_STYLE, ...textInputDefaultStyle, ...config.style }; super({...config, style: finalStyle}); this.type = 'text_input'; this.value = config.value || ""; this.placeholder = config.placeholder || "Enter text..."; this.maxLength = config.maxLength || 100; this.mesh = this.createMesh(); if (this.mesh && config.position) this.mesh.position.copy(config.position); if (this.mesh && config.rotation) this.mesh.rotation.copy(config.rotation); if (this.mesh) interactiveElements.push(this.mesh); } createMesh() { const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const currentStyle = this.style; canvas.width = Math.floor(currentStyle.width * RESOLUTION_FACTOR); canvas.height = Math.floor(currentStyle.height * RESOLUTION_FACTOR); const texture = new THREE.CanvasTexture(canvas); const updateTextureMethod = (newBgColor, newTextColor = null, newText = null, showCursor = false) => { context.fillStyle = newBgColor || currentStyle.backgroundColor; context.fillRect(0, 0, canvas.width, canvas.height); const hasValue = (newText !== null && newText !== "") || (newText === null && this.value !== ""); const textToDisplay = newText !== null ? newText : (this.value || this.placeholder); const colorToDisplay = (this.value || (newText && newText !== this.placeholder)) ? (newTextColor || currentStyle.textColor) : currentStyle.placeholderTextColor; const displayTextWithCursor = textToDisplay + (showCursor ? "|" : ""); context.font = `Bold ${currentStyle.fontSize}px ${currentStyle.fontFamily}`; context.fillStyle = colorToDisplay; context.textAlign = 'left'; context.textBaseline = 'middle'; const paddingXPx = currentStyle.padding.left * RESOLUTION_FACTOR; context.fillText(displayTextWithCursor, paddingXPx, canvas.height / 2); texture.needsUpdate = true; }; updateTextureMethod(currentStyle.backgroundColor, null, this.value || this.placeholder, false); const geometry = new THREE.PlaneGeometry(currentStyle.width, currentStyle.height); const material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8, metalness: 0.1, transparent: true, side: THREE.DoubleSide }); const mesh = new THREE.Mesh(geometry, material); mesh.name = this.id; mesh.userData = this.userData; mesh.userData.updateTextureMethod = updateTextureMethod; mesh.userData.uiElementInstance = this; return mesh; } updateAppearance(newBgColor, newTextColor = null, newText = null, showCursor = false) { if (this.mesh && this.mesh.userData.updateTextureMethod) { this.mesh.userData.updateTextureMethod(newBgColor, newTextColor, this.value, showCursor); } } onClick() { super.onClick(); }
            onKeyDown(event) { if (!this.userData.isFocused) return; if (event.key.length === 1 || event.key === 'Backspace' || event.key === 'Enter') { event.preventDefault(); event.stopPropagation(); } if (event.key.length === 1 && this.value.length < this.maxLength) { this.value += event.key; } else if (event.key === 'Backspace') { this.value = this.value.slice(0, -1); } else if (event.key === 'Enter') { console.log(`TextInput '${this.id}' Enter pressed. Value: ${this.value}`); this.setFocus(false); } this.updateAppearance(this.style.focusBackgroundColor, null, null, cursorVisible); }
        }
        class VerticalLayoutContainer { constructor(config={}) { this.group = new THREE.Group(); if(config.position)this.group.position.copy(config.position); this.elements=[]; this.itemSpacing = config.style?.itemSpacing !== undefined ? config.style.itemSpacing : GLOBAL_DEFAULT_STYLE.itemSpacing; } addElement(uiElement) { if (!(uiElement instanceof UIElement3D && uiElement.mesh)) { console.error("VerticalLayoutContainer: Attempted to add invalid element.", uiElement); return; } this.elements.push(uiElement); this.group.add(uiElement.mesh); this.performLayout(); } removeElement(uiElement) { const index = this.elements.indexOf(uiElement); if (index > -1) { this.elements.splice(index, 1); this.group.remove(uiElement.mesh); uiElement.dispose(); this.performLayout(); } } performLayout() { let totalHeight = 0; this.elements.forEach((element, index) => { totalHeight += element.style.height; if (index < this.elements.length - 1) { totalHeight += this.itemSpacing; } }); let currentY = totalHeight / 2; this.elements.forEach(element => { const elementHeight = element.style.height; element.mesh.position.y = currentY - (elementHeight / 2); element.mesh.position.x = 0; currentY -= (elementHeight + this.itemSpacing); }); } addToScene(targetScene) { targetScene.add(this.group); } dispose() { this.elements.forEach(element => element.dispose()); this.elements = []; if (this.group.parent) { this.group.parent.remove(this.group); } } }

        class MenuManager {
            constructor(renderer) { this.renderer = renderer; this.activeMenu = null; this.interactionHandler = null; this.focusedItem = null; this.themes = {...THEMES}; /* Initialize with global THEMES */ this.activeThemeName = 'default'; this.menuDefinitions = {}; this.actionRegistry={}; this.menuStack=[]; }
            registerTheme(name, themeObject) { this.themes[name] = themeObject; }
            setActiveTheme(name) { if (this.themes[name]) { this.activeThemeName = name; } else { console.warn(`Theme '${name}' not found.`); } }
            setInteractionHandler(handler) { if(this.interactionHandler && this.interactionHandler.dispose) this.interactionHandler.dispose(); this.interactionHandler = handler; if(this.interactionHandler) { this.interactionHandler.menuManager = this; if(this.activeMenu) this.interactionHandler.setActiveMenu(this.activeMenu); } }
            registerMenuDefinition(definition) { this.menuDefinitions[definition.id] = definition; }
            registerAction(actionKey, callback) { this.actionRegistry[actionKey] = callback; }
            executeAction(actionKey, menuItemInstance, optionData) { if (this.actionRegistry[actionKey]) { this.actionRegistry[actionKey](menuItemInstance, this, optionData); } else { console.warn(`Action not found: ${actionKey} for item ${menuItemInstance.id}`); } }
            loadMenu(menuId) { if (this.focusedItem) { this.focusedItem.setFocus(false); } if (this.activeMenu) { this.activeMenu.hide(); this.activeMenu.dispose(); } const definition = this.menuDefinitions[menuId]; if (!definition) { console.error(`Menu definition not found: ${menuId}`); return null; } this.activeMenu = new Menu(definition, this.renderer, this); this.activeMenu.render(); this.activeMenu.show(); this.menuStack = [this.activeMenu]; if (this.interactionHandler) this.interactionHandler.setActiveMenu(this.activeMenu); return this.activeMenu; }
            update() { if(this.interactionHandler) this.interactionHandler.update(); }
        }
        class Menu {
            constructor(menuDefinition, renderer, menuManagerInstance) {
                this.id = menuDefinition.id; this.definition = menuDefinition; this.renderer = renderer;
                this.menuManager = menuManagerInstance; this.items = [];
                const menuThemeName = menuDefinition.theme || this.menuManager.activeThemeName || 'default';
                this.activeTheme = this.menuManager.themes[menuThemeName] || GLOBAL_DEFAULT_STYLE;
                this.styleDefaults = { ...(this.activeTheme || {}), ...(menuDefinition.style || {}) };
                this.layout = menuDefinition.layout || { type: 'vertical', alignment: 'center' };
                this.group = null; this.contentGroup = null;
                this._buildItems();
            }
            _buildItems() {
                this.definition.items.forEach(itemDef => {
                    let item;
                    // Pass the renderer from MenuManager, not from UIElement3D's own config.renderer
                    const elementConfig = { ...itemDef, styleFromMenu: this.styleDefaults, renderer: this.menuManager.renderer, menuManager: this.menuManager };
                    switch (itemDef.type) {
                        case 'textlabel': item = new TextLabelElement(elementConfig); break;
                        case 'button': item = new ButtonElement(elementConfig); break;
                        case 'text_input': item = new TextInputElement(elementConfig); break;
                        default: console.warn(`Menu._buildItems: Unknown item type: ${itemDef.type} for id '${itemDef.name || 'unknown'}'`); return;
                    }
                    if (item) { this.items.push(item); }
                });
            }
            render() {
                this.group = this.renderer.createMenuView(this);
                this.contentGroup = new THREE.Group();
                this.group.add(this.contentGroup);

                this.items.forEach(item => {
                    // item.createVisuals(this.contentGroup); // Old problematic line
                    if (item.mesh) { // Corrected logic: Add existing mesh
                        this.contentGroup.add(item.mesh);
                    } else {
                        // This might happen if createMesh() failed or was not called in item's constructor
                        console.warn(`Menu.render: Item ${item.id} (type: ${item.type}) does not have a mesh to add.`);
                    }
                });

                this.renderer.applyLayoutToMenu(this);
            }
            applyLayout() { if (this.group && this.items.length > 0) { this.renderer.applyLayoutToMenu(this); } }
            getInteractiveObjects() { return this.items.filter(item => item.mesh && item.visible).map(item => item.mesh); }
            show(){if (this.group) this.renderer.setMenuViewVisibility(this, true);} hide(){if (this.group) {this.renderer.setMenuViewVisibility(this, false); if (this.menuManager.focusedItem && this.items.includes(this.menuManager.focusedItem)) { this.menuManager.focusedItem.setFocus(false);}}}
            dispose(){this.items.forEach(i=>i.dispose()); this.items = []; if (this.group) {this.renderer.disposeMenuView(this); this.group = null;} this.contentGroup = null;}
        }
        class BaseInteractionHandler { constructor() { this.menuManager = null; this.activeMenu = null; this.hoveredItem = null; this.activeElement = null; } setActiveMenu(menuInstance) { this.activeMenu = menuInstance; if (this.hoveredItem && this.hoveredItem.onUnhover) this.hoveredItem.onUnhover(); this.hoveredItem = null; this.activeElement = null;} update(){} dispose(){ this.activeElement = null;} }
        class ThreeJSRenderer { constructor(scene, camera) { this.threeScene = scene; this.camera = camera; this.textureCache = {}; this.resolutionFactor = RESOLUTION_FACTOR;} _disposeTexture(texture) { if (texture) texture.dispose(); }
            // These create*View methods are currently not used, as elements create their own meshes.
            // They are kept here for potential future refactoring.
            createButtonView(item) { const style = item.style; const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = Math.floor(style.width * this.resolutionFactor); canvas.height = Math.floor(style.height * this.resolutionFactor); const tex = new THREE.CanvasTexture(canvas); const mesh = new THREE.Mesh(new THREE.PlaneGeometry(style.width,style.height), new THREE.MeshStandardMaterial({map:tex, transparent:true, roughness:0.7,metalness:0.1, side:THREE.DoubleSide})); mesh.userData.uiElementInstance = item; mesh.userData.updateTextureMethod = (bg,tc,txt,sc) => {ctx.fillStyle = bg || style.backgroundColor; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.font = `Bold ${style.fontSize}px ${style.fontFamily}`; ctx.fillStyle = tc || style.textColor; ctx.textAlign=style.textAlign;ctx.textBaseline=style.verticalAlign; const p = style.padding; let x,y; if(style.textAlign === 'left') x=p.left*this.resolutionFactor; else if(style.textAlign === 'right') x=canvas.width-p.right*this.resolutionFactor; else x=canvas.width/2; if(style.verticalAlign === 'top') y=p.top*this.resolutionFactor; else if(style.verticalAlign === 'bottom') y=canvas.height-p.bottom*this.resolutionFactor; else y=canvas.height/2; if(ctx.textBaseline === 'top') y+= style.fontSize*0.75; else if(ctx.textBaseline === 'bottom') y-= style.fontSize*0.25; ctx.fillText(txt||item.text, x,y); tex.needsUpdate=true;}; mesh.userData.updateTextureMethod(style.backgroundColor, style.textColor, item.text, false); return mesh;}
            createTextInputView(item) { const style = item.style; const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = Math.floor(style.width * this.resolutionFactor); canvas.height = Math.floor(style.height * this.resolutionFactor); const tex = new THREE.CanvasTexture(canvas); const mesh = new THREE.Mesh(new THREE.PlaneGeometry(style.width,style.height), new THREE.MeshStandardMaterial({map:tex, transparent:true, roughness:0.7,metalness:0.1, side:THREE.DoubleSide})); mesh.userData.uiElementInstance = item; mesh.userData.updateTextureMethod = (bg,tc,txt,sc) => {ctx.fillStyle = bg || style.backgroundColor; ctx.fillRect(0,0,canvas.width,canvas.height); const hasVal = (txt !== null && txt !== "") || (txt === null && item.value !== ""); const dispTxt = txt !== null ? txt : (item.value || item.placeholder); const dispCol = (item.value || (txt && txt !== item.placeholder)) ? (tc || style.textColor) : style.placeholderTextColor; const cursorTxt = dispTxt + (sc ? "|" : ""); ctx.font = `Bold ${style.fontSize}px ${style.fontFamily}`; ctx.fillStyle = dispCol; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; const padX = style.padding.left * this.resolutionFactor; ctx.fillText(cursorTxt, padX, canvas.height/2); tex.needsUpdate = true;}; mesh.userData.updateTextureMethod(style.backgroundColor,null,item.value||item.placeholder, false); return mesh;}

            createMenuView(menuInstance) { const group = new THREE.Group(); if(menuInstance.definition.position) group.position.copy(menuInstance.definition.position); this.threeScene.add(group); return group;}
            applyLayoutToMenu(menuInstance) { const style = menuInstance.styleDefaults; const items = menuInstance.items; if(items.length === 0 || !menuInstance.contentGroup) return; let totalHeight = 0; items.forEach((item, i) => { totalHeight += item.style.height; if (i < items.length - 1) totalHeight += style.itemSpacing; }); let currentY = totalHeight / 2; items.forEach(item => { const itemH = item.style.height; if(item.mesh) {item.mesh.position.y = currentY - itemH / 2; item.mesh.position.x = 0;} currentY -= (itemH + style.itemSpacing); }); }
            updateMenuItemView(menuItem, state) { if (!menuItem.mesh || !menuItem.mesh.material ) return; const style = menuItem.style; let bgColor = style.backgroundColor; if(menuItem.type==='button' && menuItem.actionKey === null && !menuItem.action && !menuItem.userData.isFocused && !menuItem.userData.isHovered && !menuItem.userData.isActive) bgColor = style.backgroundColor; else if(state === 'focus') bgColor = style.focusBackgroundColor; else if(state === 'active') bgColor = style.activeBackgroundColor; else if(state === 'hover') bgColor = style.hoverBackgroundColor; if(menuItem.mesh.userData.updateTextureMethod) menuItem.mesh.userData.updateTextureMethod(bgColor, null, null, menuItem.type === 'text_input' && state==='focus' ? cursorVisible: false); }
            disposeMenuView(menuInstance) { if(menuInstance.group && menuInstance.group.parent) menuInstance.group.parent.remove(menuInstance.group); } setMenuViewVisibility(m,v){if(m.group)m.group.visible=v;}
        }
        class MouseInteractionHandler extends BaseInteractionHandler { constructor(rendererDomElement, camera) { super(); this.rendererDomElement = rendererDomElement; this.camera = camera; this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2(); this._onMouseMove = this._onMouseMove.bind(this); this._onMouseDown = this._onMouseDown.bind(this); this._onMouseUp = this._onMouseUp.bind(this); this._onMouseWheel = this._onMouseWheel.bind(this); this.rendererDomElement.addEventListener('mousemove', this._onMouseMove); this.rendererDomElement.addEventListener('mousedown', this._onMouseDown); document.addEventListener('mouseup', this._onMouseUp); this.rendererDomElement.addEventListener('wheel', this._onMouseWheel, {passive: false}); }
            _onMouseMove(event) { const rect = this.rendererDomElement.getBoundingClientRect(); this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; if (!this.activeMenu || !this.activeMenu.group || !this.activeMenu.group.visible || this.activeElement) return; this.raycaster.setFromCamera(this.mouse, this.camera); const intersects = this.raycaster.intersectObjects(this.activeMenu.getInteractiveObjects(), false); let currentIntersectedUIElement = null; if (intersects.length > 0) currentIntersectedUIElement = intersects[0].object.userData.uiElementInstance; if (this.hoveredItem !== currentIntersectedUIElement) { if (this.hoveredItem) this.hoveredItem.onUnhover(); this.hoveredItem = currentIntersectedUIElement; if (this.hoveredItem) this.hoveredItem.onHover(); } }
            _onMouseDown(event) { if (!this.activeMenu || !this.activeMenu.group ||!this.activeMenu.group.visible) return; this.raycaster.setFromCamera(this.mouse, this.camera); const intersects = this.raycaster.intersectObjects(this.activeMenu.getInteractiveObjects(), false); if (intersects.length > 0) { const clickedElement = intersects[0].object.userData.uiElementInstance; if (clickedElement) { this.activeElement = clickedElement; if (typeof clickedElement.onMouseDown === 'function') clickedElement.onMouseDown(); } } }
            _onMouseUp(event) { if (this.activeElement) { this.raycaster.setFromCamera(this.mouse, this.camera); const intersects = this.raycaster.intersectObjects(this.activeMenu.getInteractiveObjects(), false); let releasedOverActive = false; if (intersects.length > 0 && this.activeElement) { if (intersects[0].object.userData.uiElementInstance === this.activeElement) releasedOverActive = true; } if (typeof this.activeElement.onMouseUp === 'function') this.activeElement.onMouseUp(); if (releasedOverActive && typeof this.activeElement.onClick === 'function') this.activeElement.onClick(); else if (this.menuManager.focusedItem && this.menuManager.focusedItem !== this.activeElement) this.menuManager.focusedItem.setFocus(false); this.activeElement = null; } else { this.raycaster.setFromCamera(this.mouse, this.camera); if(!this.activeMenu || !this.activeMenu.group || !this.activeMenu.group.visible) return; const intersects = this.raycaster.intersectObjects(this.activeMenu.getInteractiveObjects(), false); if(intersects.length === 0 && this.menuManager.focusedItem) this.menuManager.focusedItem.setFocus(false); } }
            _onMouseWheel(event) { /* Stubbed for now */ }
            dispose() { this.rendererDomElement.removeEventListener('mousemove',this._onMouseMove); this.rendererDomElement.removeEventListener('mousedown',this._onMouseDown); document.removeEventListener('mouseup', this._onMouseUp); this.rendererDomElement.removeEventListener('wheel', this._onMouseWheel); } update(){}
        }
        class XRControllerInteractionHandler extends BaseInteractionHandler { update(){} dispose(){} }

        function startBlinkingCursor() { stopBlinkingCursor(); cursorVisible = true; if (menuManager.focusedItem && menuManager.focusedItem.type === 'text_input') { menuManager.focusedItem.updateAppearance(menuManager.focusedItem.style.focusBackgroundColor, null, null, cursorVisible); } blinkTimer = setInterval(() => { cursorVisible = !cursorVisible; if (menuManager.focusedItem && menuManager.focusedItem.type === 'text_input' && menuManager.focusedItem.userData.isFocused) { menuManager.focusedItem.updateAppearance(menuManager.focusedItem.style.focusBackgroundColor, null, null, cursorVisible); } else { stopBlinkingCursor(); } }, BLINK_INTERVAL); }
        function stopBlinkingCursor() { if (blinkTimer) { clearInterval(blinkTimer); blinkTimer = null; } cursorVisible = false; if (menuManager.focusedItem && menuManager.focusedItem.type === 'text_input' && menuManager.focusedItem.userData.isFocused) { menuManager.focusedItem.updateAppearance(menuManager.focusedItem.style.focusBackgroundColor, null, null, false); } }

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x222233);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 4); renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.target.set(0, 1.0, 0); controls.update();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight);
            // raycaster = new THREE.Raycaster(); // Used by MouseInteractionHandler
            // mouse = new THREE.Vector2(); // Used by MouseInteractionHandler
            interactiveElements = []; // Cleared, as elements add their meshes individually. Interaction handler gets meshes from activeMenu.

            const menuRenderer = new ThreeJSRenderer(scene, camera);
            menuManager = new MenuManager(menuRenderer);
            const mouseInteractionHandler = new MouseInteractionHandler(renderer.domElement, camera);
            const xrInteractionHandler = new XRControllerInteractionHandler(/*renderer*/); // XR handler might need renderer or session
            menuManager.setInteractionHandler(mouseInteractionHandler);

            const vrButton = VRButton.createButton(renderer); document.body.appendChild(vrButton);
            renderer.xr.enabled = true;
            renderer.xr.addEventListener('sessionstart', () => { if(controls) controls.enabled = false; if(menuManager) menuManager.setInteractionHandler(xrInteractionHandler);});
            renderer.xr.addEventListener('sessionend', () => { if(controls) controls.enabled = true; if(menuManager) menuManager.setInteractionHandler(mouseInteractionHandler);});

            menuManager.registerMenuDefinition(testMenuDefinition);
            menuManager.registerAction("logNameAction", (item, manager) => {
                const nameField = manager.activeMenu.items.find(i => i.id === 'nameField');
                if (nameField) { document.getElementById('info').textContent = `Name: ${nameField.value}`; }
                else { document.getElementById('info').textContent = `Name field not found.`; }
            });
            menuManager.loadMenu('mainTestMenu');

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (event) => {
                if (menuManager.focusedItem) {
                    if (event.key === 'Escape') {
                        menuManager.focusedItem.setFocus(false);
                        event.preventDefault();
                    } else if (typeof menuManager.focusedItem.onKeyDown === 'function') {
                        menuManager.focusedItem.onKeyDown(event);
                    }
                }
            });
            renderer.setAnimationLoop(animate);
            document.getElementById('info').textContent = "Definitive Iteration 0.7: Desktop TextInput.";
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            if(controls && controls.enabled) controls.update(); // Only update if enabled
            if(menuManager && menuManager.interactionHandler) menuManager.interactionHandler.update();
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
